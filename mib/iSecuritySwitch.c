/*
 * Note: this file originally auto-generated by mib2c
 * using mib2c.old-api.conf
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "iSecuritySwitch.h"

/* 
 * iSecuritySwitch_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid iSecuritySwitch_variables_oid[] = { 1,3,6,1,4,1,4756,136,40,1 };

/* 
 * variable4 iSecuritySwitch_variables:
 *   this variable defines function callbacks and type return information 
 *   for the iSecuritySwitch mib section 
 */

struct variable4 iSecuritySwitch_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define IADDUSER		1
{IADDUSER,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_iSecuritySwitch, 1,  { 1 }},
#define IDELETEUSER		2
{IDELETEUSER,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_iSecuritySwitch, 1,  { 2 }},
#define ISSHMODE		3
{ISSHMODE,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iSecuritySwitch, 1,  { 6 }},
#define IHTTPSMODE		4
{IHTTPSMODE,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iSecuritySwitch, 1,  { 7 }},
#define IHTTPSAUTOMATICREDIRECT		5
{IHTTPSAUTOMATICREDIRECT,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iSecuritySwitch, 1,  { 8 }},
#define IACCESSMGMTPROTOCOLMODE		6
{IACCESSMGMTPROTOCOLMODE,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iSecuritySwitch, 2,  { 9,1 }},
#define IADDACCESSMGMTPROTOCOL		7
{IADDACCESSMGMTPROTOCOL,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_iSecuritySwitch, 2,  { 9,2 }},
#define IDELETEACCESSMGMTPROTOCOL		8
{IDELETEACCESSMGMTPROTOCOL,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_iSecuritySwitch, 2,  { 9,3 }},
#define IACCESSMGMTSTATISTICSCLEAR		9
{IACCESSMGMTSTATISTICSCLEAR,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iSecuritySwitch, 2,  { 9,5 }},

#define IUSERINDEX		1
{IUSERINDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_iUserConfigTable, 3,  { 3 , 1, 1 }},
#define IUSERNAME		2
{IUSERNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_iUserConfigTable, 3,  { 3 , 1, 2 }},
#define IUSERPASSWORD		3
{IUSERPASSWORD,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_iUserConfigTable, 3,  { 3 , 1, 3 }},
#define IUSERPRIVILEGELEVEL		4
{IUSERPRIVILEGELEVEL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iUserConfigTable, 3,  { 3 , 1, 4 }},
#define IPRIVILEGEGROUPID		1
{IPRIVILEGEGROUPID,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_iPrivilegeLevelTable, 3,  { 4 , 1, 1 }},
#define IPRIVILEGEGROUPNAME		2
{IPRIVILEGEGROUPNAME,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_iPrivilegeLevelTable, 3,  { 4 , 1, 2 }},
#define IPRIVILEGECONFIGREADONLYLEVEL		3
{IPRIVILEGECONFIGREADONLYLEVEL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iPrivilegeLevelTable, 3,  { 4 , 1, 3 }},
#define IPRIVILEGECONFIGREADWRITELEVEL		4
{IPRIVILEGECONFIGREADWRITELEVEL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iPrivilegeLevelTable, 3,  { 4 , 1, 4 }},
#define IPRIVILEGESTATUSREADONLYLEVEL		5
{IPRIVILEGESTATUSREADONLYLEVEL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iPrivilegeLevelTable, 3,  { 4 , 1, 5 }},
#define IPRIVILEGESTATUSREADWRITELEVEL		6
{IPRIVILEGESTATUSREADWRITELEVEL,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iPrivilegeLevelTable, 3,  { 4 , 1, 6 }},
#define IAUTHENTICATIONCLIENTINDEX		1
{IAUTHENTICATIONCLIENTINDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_iAuthenticationMethodTable, 3,  { 5 , 1, 1 }},
#define IAUTHENTICATIONCLIENTINTERFACE		2
{IAUTHENTICATIONCLIENTINTERFACE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_iAuthenticationMethodTable, 3,  { 5 , 1, 2 }},
#define IAUTHENTICATIONMETHOD1		3
{IAUTHENTICATIONMETHOD1,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iAuthenticationMethodTable, 3,  { 5 , 1, 3 }},
#define IAUTHENTICATIONMETHOD2		4
{IAUTHENTICATIONMETHOD2,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iAuthenticationMethodTable, 3,  { 5 , 1, 4 }},
#define IAUTHENTICATIONMETHOD3		5
{IAUTHENTICATIONMETHOD3,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iAuthenticationMethodTable, 3,  { 5 , 1, 5 }},
#define IACCESSMGMTINDEX		1
{IACCESSMGMTINDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_iAccessMgmtProtocolTable, 4,  { 9,4 , 1, 1 }},
#define IACCESSMGMTVID		2
{IACCESSMGMTVID,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iAccessMgmtProtocolTable, 4,  { 9,4 , 1, 2 }},
#define IACCESSMGMTPROTOCOLSTARTIP		3
{IACCESSMGMTPROTOCOLSTARTIP,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_iAccessMgmtProtocolTable, 4,  { 9,4 , 1, 3 }},
#define IACCESSMGMTPROTOCOLENDIP		4
{IACCESSMGMTPROTOCOLENDIP,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_iAccessMgmtProtocolTable, 4,  { 9,4 , 1, 4 }},
#define IACCESSMGMTHTTPHTTPSENABLE		5
{IACCESSMGMTHTTPHTTPSENABLE,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iAccessMgmtProtocolTable, 4,  { 9,4 , 1, 5 }},
#define IACCESSMGMTSNMPENABLE		6
{IACCESSMGMTSNMPENABLE,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iAccessMgmtProtocolTable, 4,  { 9,4 , 1, 6 }},
#define IACCESSMGMTTELNETSSHENABLE		7
{IACCESSMGMTTELNETSSHENABLE,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_iAccessMgmtProtocolTable, 4,  { 9,4 , 1, 7 }},
#define IACCESSMGMTINTERFACEINDEX		1
{IACCESSMGMTINTERFACEINDEX,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_iAccessMgmtStatisticsTable, 4,  { 9,6 , 1, 1 }},
#define IACCESSMGMTINTERFACE		2
{IACCESSMGMTINTERFACE,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RONLY,
 var_iAccessMgmtStatisticsTable, 4,  { 9,6 , 1, 2 }},
#define IACCESSMGMTRECEIVEDPACKETS		3
{IACCESSMGMTRECEIVEDPACKETS,  ASN_COUNTER,  NETSNMP_OLDAPI_RONLY,
 var_iAccessMgmtStatisticsTable, 4,  { 9,6 , 1, 3 }},
#define IACCESSMGMTALLOWEDPACKETS		4
{IACCESSMGMTALLOWEDPACKETS,  ASN_COUNTER,  NETSNMP_OLDAPI_RONLY,
 var_iAccessMgmtStatisticsTable, 4,  { 9,6 , 1, 4 }},
#define IACCESSMGMTDISCARDEDPACKETS		5
{IACCESSMGMTDISCARDEDPACKETS,  ASN_COUNTER,  NETSNMP_OLDAPI_RONLY,
 var_iAccessMgmtStatisticsTable, 4,  { 9,6 , 1, 5 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the iSecuritySwitch module */
void
init_iSecuritySwitch(void)
{

    DEBUGMSGTL(("iSecuritySwitch", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("iSecuritySwitch", iSecuritySwitch_variables, variable4,
               iSecuritySwitch_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * var_iSecuritySwitch():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_iSecuritySwitch(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case IADDUSER:
        *write_method = write_iAddUser;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IDELETEUSER:
        *write_method = write_iDeleteUser;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case ISSHMODE:
        *write_method = write_iSshMode;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IHTTPSMODE:
        *write_method = write_iHttpsMode;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IHTTPSAUTOMATICREDIRECT:
        *write_method = write_iHttpsAutomaticRedirect;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTPROTOCOLMODE:
        *write_method = write_iAccessMgmtProtocolMode;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IADDACCESSMGMTPROTOCOL:
        *write_method = write_iAddAccessMgmtProtocol;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IDELETEACCESSMGMTPROTOCOL:
        *write_method = write_iDeleteAccessMgmtProtocol;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTSTATISTICSCLEAR:
        *write_method = write_iAccessMgmtStatisticsClear;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_iUserConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_iSecuritySwitch above.
 */
unsigned char *
var_iUserConfigTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case IUSERINDEX:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IUSERNAME:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IUSERPASSWORD:
        *write_method = write_iUserPassword;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IUSERPRIVILEGELEVEL:
        *write_method = write_iUserPrivilegeLevel;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_iPrivilegeLevelTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_iSecuritySwitch above.
 */
unsigned char *
var_iPrivilegeLevelTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case IPRIVILEGEGROUPID:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IPRIVILEGEGROUPNAME:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IPRIVILEGECONFIGREADONLYLEVEL:
        *write_method = write_iPrivilegeConfigReadOnlyLevel;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IPRIVILEGECONFIGREADWRITELEVEL:
        *write_method = write_iPrivilegeConfigReadWriteLevel;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IPRIVILEGESTATUSREADONLYLEVEL:
        *write_method = write_iPrivilegeStatusReadOnlyLevel;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IPRIVILEGESTATUSREADWRITELEVEL:
        *write_method = write_iPrivilegeStatusReadWriteLevel;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_iAuthenticationMethodTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_iSecuritySwitch above.
 */
unsigned char *
var_iAuthenticationMethodTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case IAUTHENTICATIONCLIENTINDEX:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IAUTHENTICATIONCLIENTINTERFACE:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IAUTHENTICATIONMETHOD1:
        *write_method = write_iAuthenticationMethod1;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IAUTHENTICATIONMETHOD2:
        *write_method = write_iAuthenticationMethod2;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IAUTHENTICATIONMETHOD3:
        *write_method = write_iAuthenticationMethod3;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_iAccessMgmtProtocolTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_iSecuritySwitch above.
 */
unsigned char *
var_iAccessMgmtProtocolTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case IACCESSMGMTINDEX:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTVID:
        *write_method = write_iAccessMgmtVID;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTPROTOCOLSTARTIP:
        *write_method = write_iAccessMgmtProtocolStartIP;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTPROTOCOLENDIP:
        *write_method = write_iAccessMgmtProtocolEndIP;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTHTTPHTTPSENABLE:
        *write_method = write_iAccessMgmtHttpHttpsEnable;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTSNMPENABLE:
        *write_method = write_iAccessMgmtSnmpEnable;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTTELNETSSHENABLE:
        *write_method = write_iAccessMgmtTelnetSshEnable;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_iAccessMgmtStatisticsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_iSecuritySwitch above.
 */
unsigned char *
var_iAccessMgmtStatisticsTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case IACCESSMGMTINTERFACEINDEX:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTINTERFACE:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTRECEIVEDPACKETS:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTALLOWEDPACKETS:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case IACCESSMGMTDISCARDEDPACKETS:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}



int
write_iAddUser(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_iDeleteUser(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_iSshMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_iHttpsMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_iHttpsAutomaticRedirect(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_iAccessMgmtProtocolMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_iAddAccessMgmtProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_iDeleteAccessMgmtProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_iAccessMgmtStatisticsClear(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_iUserPassword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iUserPrivilegeLevel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iPrivilegeConfigReadOnlyLevel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iPrivilegeConfigReadWriteLevel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iPrivilegeStatusReadOnlyLevel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iPrivilegeStatusReadWriteLevel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iAuthenticationMethod1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iAuthenticationMethod2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iAuthenticationMethod3(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iAccessMgmtVID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iAccessMgmtProtocolStartIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iAccessMgmtProtocolEndIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iAccessMgmtHttpHttpsEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iAccessMgmtSnmpEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_iAccessMgmtTelnetSshEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to iSecuritySwitch not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to iSecuritySwitch: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
